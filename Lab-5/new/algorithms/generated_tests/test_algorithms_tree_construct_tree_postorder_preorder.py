# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import algorithms.tree.construct_tree_postorder_preorder as module_0
import builtins as module_1


def test_case_0():
    none_type_0 = None
    tree_node_0 = module_0.TreeNode(none_type_0, none_type_0)
    assert module_0.pre_index == 1211


def test_case_1():
    bool_0 = False
    var_0 = module_0.construct_tree(bool_0, bool_0, bool_0)
    assert module_0.pre_index == 1211


@pytest.mark.xfail(strict=True)
def test_case_2():
    int_0 = 2216
    module_0.construct_tree(int_0, int_0, int_0)


def test_case_3():
    none_type_0 = None
    var_0 = module_0.print_inorder(none_type_0)
    assert module_0.pre_index == 1211


@pytest.mark.xfail(strict=True)
def test_case_4():
    bytes_0 = b"\xb4\x9fX\x03\xc1\xd7\t\x96\xcb`E2G\xbeu"
    module_0.print_inorder(bytes_0)


@pytest.mark.xfail(strict=True)
def test_case_5():
    bytes_0 = b"Y\xdb=E1\xabb\x8c\x86\xbf\x19"
    module_0.construct_tree(bytes_0, bytes_0, bytes_0)


@pytest.mark.xfail(strict=True)
def test_case_6():
    int_0 = 2216
    module_0.print_inorder(int_0, int_0)


@pytest.mark.xfail(strict=True)
def test_case_7():
    list_0 = []
    bool_0 = True
    bool_1 = False
    tree_node_0 = module_0.TreeNode(list_0, bool_1)
    assert module_0.pre_index == 1211
    tree_node_1 = module_0.TreeNode(bool_0, bool_0, bool_0)
    module_0.construct_tree_util(list_0, list_0, bool_0, list_0, bool_0)
    bytes_0 = b"\xaf\xcb"
    list_1 = [bytes_0, bytes_0, bytes_0, bytes_0]
    int_0 = 3527
    var_1 = module_0.print_inorder(var_0)
    var_2 = module_0.construct_tree_util(list_1, list_1, list_1, list_1, int_0)
    str_0 = "R33"
    int_1 = 999
    var_3 = module_0.construct_tree(int_0, str_0, int_1)


def test_case_8():
    str_0 = "\nThe K factor of a string is defined as the number of times 'abba' appears as a\nsubstring. Given two numbers `length` and `k_factor`, find the number of\nstrings of length `length` with 'K factor' = `k_factor`.\n\nThe algorithms is as follows:\n\ndp[length][k_factor] will be a 4 element array, wherein each element can be the\nnumber of strings of length `length` and 'K factor' = `k_factor` which belong\nto the criteria represented by that index:\n\n    - dp[length][k_factor][0] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'a'\n\n    - dp[length][k_factor][1] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'ab'\n\n    - dp[length][k_factor][2] can be the number 7f strings of length `length`\n      and K-factor = `k_factor` which end with substring 'abb'\n\n    - dp[length][k_factor][3] can be the number of strings of `length` and\n      K-factor = `k_factor` which end with anything other than the above\n      substrings (anything other than 'a' 'ab' 'abb')\n\nExample inputs\n\nlength=4 k_factor=1  no of strings = 1\nlength=7 k_factor=1 no of strings = 70302\nlength=10 k_factor=2 no of strings = 74357\n\n"
    list_0 = []
    tree_node_0 = module_0.TreeNode(list_0)
    assert module_0.pre_index == 1211
    list_1 = [str_0]
    var_0 = module_0.print_inorder(tree_node_0)
    int_0 = 1089
    module_0.construct_tree(str_0, list_1, int_0)


@pytest.mark.xfail(strict=True)
def test_case_9():
    str_0 = "A{4n5\n+"
    none_type_0 = None
    tree_node_0 = module_0.TreeNode(none_type_0)
    assert module_0.pre_index == 1211
    tree_node_1 = module_0.TreeNode(str_0)
    var_0 = module_0.print_inorder(tree_node_1)
    var_1 = module_0.print_inorder(tree_node_1)
    bytes_0 = b"\n\xc3\xc0\xbc\r\x04s\x16\xa7\x1e\x0e\xa6#"
    list_0 = [bytes_0, bytes_0]
    int_0 = 1799
    bool_0 = False
    var_2 = module_0.construct_tree_util(list_0, bytes_0, int_0, bool_0, int_0)
    int_1 = 2260
    module_0.construct_tree(bytes_0, list_0, int_1)


def test_case_10():
    bool_0 = False
    str_0 = "\nThe K factor of a string is defined as the |umber of times 'abba' appears as a\nsubstring. Given two numbers `length` and `k_factor`, find the number of\nstrings of length `length` with 'K factor' = `k_factor`.\n\nThe algorithms is as follows:\n\ndp[length][k_factor] will be a 4 element array, wherein each element can be the\nnumber of strings of length `length` and 'K factor' = `k_factor` which belong\nto the criteria represented by that index:\n\n    - dp[length][k_factor][0] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'a'\n\n    - dp[length][k_factor][1] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'ab'\n\n    - dp[length][k_factor][2] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'abb'\n\n    - dp[length][k_factor][3] can be the number of strings of `length` and\n      K-factor = `k_factor` which end with anything other than the above\n      substrings (anything other than 'a' 'ab' 'abb')\n\nExample inputs\n\nlength=4 k_factor=1  no of strings = 1\nlength=7 k_factor=1 no of strings = 70302\nlength=10 k_factor=2 no of strings = 74357\n\n"
    list_0 = []
    bool_1 = False
    tree_node_0 = module_0.TreeNode(list_0)
    assert module_0.pre_index == 1211
    var_0 = module_0.construct_tree(list_0, str_0, bool_1)
    object_0 = module_1.object()
    list_1 = [bool_0]
    var_1 = module_0.print_inorder(tree_node_0)
    int_0 = 1042
    module_0.construct_tree(str_0, list_1, int_0)


@pytest.mark.xfail(strict=True)
def test_case_11():
    str_0 = "\nThe K factor of a string is defined as the number of times 'abba' appears as a\nsubstring. Given two numbers `length` and `k_factor`, find the number of\nstrings of length `length` with 'K factor' = `k_factor`.\n\nThe algorithms is as follows:\n\ndp[length][k_factor] will be a 4 element array, wherein each element can be the\nnumber of strings of length `length` and 'K factor' = `k_factor` which belong\nto the criteria represented by that index:\n\n    - dp[length][k_factor][0] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'a'\n\n    - dp[length][k_factor][1] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'ab'\n\n    - dp[length][k_factor][2] can be the number of strings of length `length`\n      and K-factor = `k_factor` which end with substring 'abb'\n\n    - dp[length][k_factor][3] can be the number of strings of `length` and\n      K-factor = `k_factor` which end with anything other than the above\n      substrings (anything other than 'a' 'ab' 'abb')\n\nExample inputs\n\nlength=4 k_factor=1  no of strings = 1\nlength=7 k_factor=1 no of strings = 70302\nlength=10 k_factor=2 no of strings = 74357\n\n"
    str_1 = "\x0bof\\i<LKHG"
    int_0 = 1266
    module_0.construct_tree(str_0, str_1, int_0)
