# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import algorithms.strings.longest_palindromic_substring as module_0


def test_case_0():
    str_0 = "J\np:Lm{>\\`-4\tn u2R"
    var_0 = module_0.longest_palindrome(str_0)
    assert var_0 == "J"
    var_1 = module_0.longest_palindrome(var_0)
    assert var_1 == "J"
    var_2 = module_0.longest_palindrome(str_0)
    assert var_2 == "J"


def test_case_1():
    str_0 = "J\np:Lm{>\\`-4\tn u2R"
    var_0 = module_0.longest_palindrome(str_0)
    assert var_0 == "J"


def test_case_2():
    str_0 = "\nYou are given K eggs, and you have access to a building with N floors\nfrom 1 to N. Each egg is identical in function, and if an egg breaks,\nyou cannot drop it again. You know that there exists a floor F with\n0 <= F <= N such that any egg dropped at a floor higher than F will\nbreak, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop\nit from any floor X (with 1 <= X <= N). Your goal is to know with\ncertainty what the value of F is. What is the minimum number of moves\nthat you need to know with certainty what F is, regardless of the\ninitial value of F?\n\nExample:\nInput: K = 1, N = 2\nOutput: 2\nExplanation:\nDrop the egg from floor 1.  If it breaks, we know with certainty that F = 0.\nOtherwise, drop the egg from floor 2.  If it breaks, we know with\ncertainty that F = 1.\nIf it didn't break, then we know with certainty F = 2.\nHence, we needed 2 moves in the worst case to know what F is with certainty.\n"
    var_0 = module_0.longest_palindrome(str_0)
    assert var_0 == "minim"
